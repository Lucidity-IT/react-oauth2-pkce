{"version":3,"file":"index.modern.js","sources":["../src/AuthContext.tsx","../src/AuthProvider.tsx","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/pkce.ts","../src/util.ts","../src/AuthService.ts"],"sourcesContent":["import React, { useContext, ReactElement } from 'react'\r\n\r\nimport { AuthServiceProps, AuthService } from './AuthService'\r\n\r\nexport type AuthContextProps = {\r\n  authService: AuthService\r\n}\r\n\r\nexport type AuthContextType = AuthContextProps | undefined\r\n\r\nexport const AuthContext = React.createContext<AuthContextProps | undefined>(\r\n  undefined\r\n)\r\n\r\nexport const useAuth = (): AuthContextProps => {\r\n  const context = useContext(AuthContext)\r\n  if (context === undefined) {\r\n    throw new Error('useAuth must be used within a AuthProvider')\r\n  }\r\n  return context\r\n}\r\n\r\nexport function withAuth<T>(\r\n  ComponentToWrap: React.ComponentType<T & AuthServiceProps>\r\n): React.FC<T & AuthServiceProps> {\r\n  const WrappedComponent = (props: T & AuthServiceProps): ReactElement => {\r\n    const authProps = useAuth()\r\n    return <ComponentToWrap {...authProps} {...props} />\r\n  }\r\n  WrappedComponent.displayName =\r\n    'withAuth_' + (ComponentToWrap.displayName || ComponentToWrap.name)\r\n  return WrappedComponent\r\n}\r\n","import React, { ReactElement, ReactNode } from 'react'\r\n\r\nimport { AuthService } from './AuthService'\r\nimport { AuthContext } from './AuthContext'\r\n\r\ninterface AuthProviderProps {\r\n  children: ReactNode\r\n  authService: AuthService\r\n}\r\n\r\nexport const AuthProvider = (props: AuthProviderProps): ReactElement => {\r\n  const { authService, children } = props\r\n\r\n  return (\r\n    <AuthContext.Provider value={{ authService }}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  )\r\n}\r\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { randomBytes, createHash } from 'crypto'\r\n\r\nexport type PKCECodePair = {\r\n  codeVerifier: string\r\n  codeChallenge: string\r\n  createdAt: Date\r\n}\r\n\r\nexport const base64URLEncode = (str: Buffer): string => {\r\n  return str\r\n    .toString('base64')\r\n    .replace(/\\+/g, '-')\r\n    .replace(/\\//g, '_')\r\n    .replace(/=/g, '')\r\n}\r\n\r\nexport const sha256 = (buffer: Buffer): Buffer => {\r\n  return createHash('sha256').update(buffer).digest()\r\n}\r\n\r\nexport const createPKCECodes = (): PKCECodePair => {\r\n  const codeVerifier = base64URLEncode(randomBytes(64))\r\n  const codeChallenge = base64URLEncode(sha256(Buffer.from(codeVerifier)))\r\n  const createdAt = new Date()\r\n  const codePair = {\r\n    codeVerifier,\r\n    codeChallenge,\r\n    createdAt\r\n  }\r\n  return codePair\r\n}\r\n","export const toSnakeCase = (str: string): string => {\r\n  return str\r\n    .split(/(?=[A-Z])/)\r\n    .join('_')\r\n    .toLowerCase()\r\n}\r\n\r\nexport const toUrlEncoded = (obj: {}): string => {\r\n  return Object.keys(obj)\r\n    .map(\r\n      (k) =>\r\n        encodeURIComponent(toSnakeCase(k)) + '=' + encodeURIComponent(obj[k])\r\n    )\r\n    .join('&')\r\n}\r\n","/* eslint-disable @typescript-eslint/camelcase */\r\nimport { createPKCECodes, PKCECodePair } from './pkce'\r\nimport { toUrlEncoded } from './util'\r\n\r\nimport jwtDecode from 'jwt-decode'\r\n\r\nexport interface AuthServiceProps {\r\n  clientId: string\r\n  clientSecret?: string\r\n  contentType?: string,\r\n  id_token_hint: string,\r\n  location: Location\r\n  provider: string\r\n  authorizeEndpoint?: string\r\n  tokenEndpoint?: string\r\n  logoutEndpoint?: string\r\n  audience?: string\r\n  redirectUri?: string\r\n  scopes: string[]\r\n  autoRefresh?: boolean\r\n  refreshSlack?: number\r\n}\r\n\r\nexport interface AuthTokens {\r\n  id_token: string\r\n  access_token: string\r\n  refresh_token: string\r\n  expires_in: number\r\n  expires_at?: number // calculated on login\r\n  token_type: string\r\n}\r\n\r\nexport interface JWTIDToken {\r\n  given_name: string\r\n  family_name: string\r\n  name: string\r\n  email: string\r\n}\r\n\r\nexport interface TokenRequestBody {\r\n  clientId: string\r\n  grantType: string\r\n  redirectUri?: string\r\n  refresh_token?: string\r\n  clientSecret?: string\r\n  code?: string\r\n  codeVerifier?: string\r\n}\r\n\r\nexport enum UXType {\r\n  POPUP,\r\n  REDIRECTION\r\n}\r\n\r\nexport type AuthError = {\r\n  message: string | null | unknown\r\n}\r\n\r\ntype PromisedResponseError<R, E = AuthError> = Promise<{\r\n  response?: R\r\n  error?: E\r\n}>\r\n\r\nconst POPUP_WIDTH = 400\r\nconst POPUP_HEIGHT = 426\r\nconst ACCESS_TOKEN_GREASE_BOSS_EVENT = 'ACCESS_TOKEN_GREASE_BOSS_EVENT'\r\n\r\nexport class AuthService<TIDToken = JWTIDToken> {\r\n  props: AuthServiceProps\r\n  timeout?: number\r\n\r\n  constructor(props: AuthServiceProps) {\r\n    this.props = props\r\n  }\r\n\r\n  getUser(): {} {\r\n    const t = this.getAuthTokens()\r\n    if (null === t) return {}\r\n    const decoded = jwtDecode(t.id_token) as TIDToken\r\n    return decoded\r\n  }\r\n\r\n  getCodeFromLocation(location: Location): string | null {\r\n    const split = location.toString().split('?')\r\n    if (split.length < 2) {\r\n      return null\r\n    }\r\n    const pairs = split[1].split('&')\r\n    for (const pair of pairs) {\r\n      const [key, value] = pair.split('=')\r\n      if (key === 'code') {\r\n        return decodeURIComponent(value || '')\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  removeCodeFromLocation(): void {\r\n    const [base, search] = window.location.href.split('?')\r\n    if (!search) {\r\n      return\r\n    }\r\n    const newSearch = search\r\n      .split('&')\r\n      .map((param) => param.split('='))\r\n      .filter(([key]) => key !== 'code')\r\n      .map((keyAndVal) => keyAndVal.join('='))\r\n      .join('&')\r\n    window.history.replaceState(\r\n      window.history.state,\r\n      'null',\r\n      base + (newSearch.length ? `?${newSearch}` : '')\r\n    )\r\n  }\r\n\r\n  getItem(key: string): string | null {\r\n    return window.localStorage.getItem(key)\r\n  }\r\n  removeItem(key: string): void {\r\n    window.localStorage.removeItem(key)\r\n  }\r\n\r\n  getPkce(): PKCECodePair {\r\n    const pkce = window.localStorage.getItem('pkce')\r\n    if (null === pkce) {\r\n      throw new Error('PKCE pair not found in local storage')\r\n    } else {\r\n      return JSON.parse(pkce)\r\n    }\r\n  }\r\n\r\n  setAuthTokens(auth: AuthTokens): void {\r\n    const { refreshSlack = 5 } = this.props\r\n    const now = new Date().getTime()\r\n    auth.expires_at = now + (auth.expires_in + refreshSlack) * 1000\r\n    window.localStorage.setItem('auth', JSON.stringify(auth))\r\n  }\r\n\r\n  getAuthTokens(): AuthTokens {\r\n    return JSON.parse(window.localStorage.getItem('auth') || '{}')\r\n  }\r\n\r\n  isPending(): boolean {\r\n    return (\r\n      window.localStorage.getItem('pkce') !== null &&\r\n      window.localStorage.getItem('auth') === null\r\n    )\r\n  }\r\n\r\n  isAuthenticated(): boolean {\r\n    return window.localStorage.getItem('auth') !== null\r\n  }\r\n\r\n  async logout(shouldEndSession = false): Promise<boolean> {\r\n\r\n    let token = JSON.parse(localStorage.getItem('auth') || '{}')\r\n\r\n    if (shouldEndSession) {\r\n\r\n      const { logoutEndpoint, redirectUri } = this.props\r\n      let id_token_hint = token?.access_token\r\n      const query = {\r\n        id_token_hint: id_token_hint,\r\n        post_logout_redirect_uri: redirectUri\r\n      }\r\n      const url = `${logoutEndpoint}?${toUrlEncoded(\r\n        query\r\n      )}`\r\n      this.removeItem('pkce')\r\n      this.removeItem('auth')\r\n      window.location.replace(url)\r\n      return true\r\n    } else {\r\n      this.removeItem('pkce')\r\n      this.removeItem('auth')\r\n      window.location.reload()\r\n      return true\r\n    }\r\n  }\r\n\r\n  async login(): Promise<void> {\r\n    this.authorize()\r\n  }\r\n\r\n  getAuthorizeUri(): string {\r\n    const {\r\n      clientId,\r\n      provider,\r\n      authorizeEndpoint,\r\n      redirectUri,\r\n      scopes,\r\n      audience\r\n    } = this.props\r\n\r\n    const pkce = createPKCECodes()\r\n    window.localStorage.setItem('pkce', JSON.stringify(pkce))\r\n    window.localStorage.setItem('preAuthUri', location.href)\r\n    window.localStorage.removeItem('auth')\r\n    const codeChallenge = pkce.codeChallenge\r\n\r\n    const query = {\r\n      clientId,\r\n      scope: scopes.join(' '),\r\n      responseType: 'code',\r\n      redirectUri,\r\n      ...(audience && { audience }),\r\n      codeChallenge,\r\n      codeChallengeMethod: 'S256'\r\n    }\r\n    // Responds with a 302 redirect\r\n    const url = `${authorizeEndpoint || `${provider}/authorize`}?${toUrlEncoded(\r\n      query\r\n    )}`\r\n    return url\r\n  }\r\n\r\n  // this will do a full page reload and to to the OAuth2 provider's login page and then redirect back to redirectUri\r\n  authorize(): boolean {\r\n    const url = this.getAuthorizeUri()\r\n    window.location.replace(url)\r\n    return true\r\n  }\r\n\r\n  async authenticate(): Promise<PromisedResponseError<string | null>> {\r\n    try {\r\n      const response = await this.authenticateUsingOAuth(UXType.POPUP)\r\n      if (!response) {\r\n        throw 'No message received'\r\n      }\r\n      if (response !== null) {\r\n        this.fetchToken(response)\r\n          .then(() => {\r\n            this.restoreUri()\r\n          })\r\n          .catch((e) => {\r\n            this.removeItem('pkce')\r\n            this.removeItem('auth')\r\n            this.removeCodeFromLocation()\r\n            console.warn({ e })\r\n          })\r\n      } else if (this.props.autoRefresh) {\r\n        this.startTimer()\r\n      }\r\n      return { response }\r\n    } catch (e) {\r\n      return { error: { message: e } }\r\n    }\r\n  }\r\n\r\n  async authenticateUsingOAuth(uxType: UXType): Promise<string | void> {\r\n    switch (uxType) {\r\n      case UXType.POPUP: {\r\n        this.launchPopup()\r\n        return new Promise<string>((resolve, reject) => {\r\n          this.listenToMessageEvent(resolve, reject)\r\n        })\r\n      }\r\n      default:\r\n        return Promise.reject('Wrong UXType passed')\r\n    }\r\n  }\r\n\r\n  // this happens after a full page reload. Read the code from localstorage\r\n  async fetchToken(code: string, isRefresh = false): Promise<AuthTokens> {\r\n    const {\r\n      clientId,\r\n      clientSecret,\r\n      contentType,\r\n      provider,\r\n      tokenEndpoint,\r\n      redirectUri,\r\n      autoRefresh = true\r\n    } = this.props\r\n    const grantType = 'authorization_code'\r\n\r\n    let payload: TokenRequestBody = {\r\n      clientId,\r\n      ...(clientSecret ? { clientSecret } : {}),\r\n      redirectUri,\r\n      grantType\r\n    }\r\n    if (isRefresh) {\r\n      payload = {\r\n        ...payload,\r\n        grantType: 'refresh_token',\r\n        refresh_token: code\r\n      }\r\n    } else {\r\n      const pkce: PKCECodePair = this.getPkce()\r\n      const codeVerifier = pkce.codeVerifier\r\n      payload = {\r\n        ...payload,\r\n        code,\r\n        codeVerifier\r\n      }\r\n    }\r\n\r\n    const response = await fetch(`${tokenEndpoint || `${provider}/token`}`, {\r\n      headers: {\r\n        'Content-Type': contentType || 'application/x-www-form-urlencoded'\r\n      },\r\n      method: 'POST',\r\n      body: toUrlEncoded(payload)\r\n    })\r\n    this.removeItem('pkce')\r\n    const json = await response.json()\r\n    if (isRefresh && !json.refresh_token) {\r\n      json.refresh_token = payload.refresh_token\r\n    }\r\n    this.setAuthTokens(json as AuthTokens)\r\n    if (autoRefresh) {\r\n      this.startTimer()\r\n    }\r\n    return this.getAuthTokens()\r\n  }\r\n\r\n  armRefreshTimer(refreshToken: string, timeoutDuration: number): void {\r\n    if (this.timeout) {\r\n      clearTimeout(this.timeout)\r\n    }\r\n    this.timeout = window.setTimeout(() => {\r\n      this.fetchToken(refreshToken, true)\r\n        .then(({ refresh_token: newRefreshToken, expires_at: expiresAt }) => {\r\n          if (!expiresAt) return\r\n          const now = new Date().getTime()\r\n          const timeout = expiresAt - now\r\n          if (timeout > 0) {\r\n            this.armRefreshTimer(newRefreshToken, timeout)\r\n          } else {\r\n            this.removeItem('auth')\r\n            this.removeCodeFromLocation()\r\n          }\r\n        })\r\n        .catch((e) => {\r\n          this.removeItem('auth')\r\n          this.removeCodeFromLocation()\r\n          console.warn({ e })\r\n        })\r\n    }, timeoutDuration)\r\n  }\r\n\r\n  startTimer(): void {\r\n    const authTokens = this.getAuthTokens()\r\n    if (!authTokens) {\r\n      return\r\n    }\r\n    const { refresh_token: refreshToken, expires_at: expiresAt } = authTokens\r\n    if (!expiresAt || !refreshToken) {\r\n      return\r\n    }\r\n    const now = new Date().getTime()\r\n    const timeout = expiresAt - now\r\n    if (timeout > 0) {\r\n      this.armRefreshTimer(refreshToken, timeout)\r\n    } else {\r\n      this.removeItem('auth')\r\n      this.removeCodeFromLocation()\r\n    }\r\n  }\r\n\r\n  restoreUri(): void {\r\n    window.location.replace('/')\r\n  }\r\n\r\n  launchPopup(): void {\r\n    const left = window.screen.width / 2 - POPUP_WIDTH / 2\r\n    const top = window.screen.height / 2 - POPUP_HEIGHT / 2\r\n    const win = window.open(\r\n      this.getAuthorizeUri(),\r\n      'Swiggy Login',\r\n      'resizable=no,scrollbars=no,status=no, width=' +\r\n      POPUP_WIDTH +\r\n      ', height=' +\r\n      POPUP_HEIGHT +\r\n      ', top=' +\r\n      top +\r\n      ', left=' +\r\n      left\r\n    )\r\n    if (win) {\r\n      win.opener = window\r\n      const timer = setInterval(() => {\r\n        try {\r\n          const a = win.document.createElement('a')\r\n          a.href = win.document.URL\r\n          if (a.hostname === window.location.hostname) {\r\n            this.onLocationChangeHandler(win)\r\n            timer && clearInterval(timer)\r\n          }\r\n        } catch (e) {\r\n          console.log('timer host name checking error: ', e)\r\n        }\r\n      }, 100)\r\n    }\r\n  }\r\n\r\n  onLocationChangeHandler(window: Window): void {\r\n    const code = this.getCodeFromLocation(window.location)\r\n    if (!window.opener) {\r\n      return\r\n    }\r\n    if (!code) {\r\n      window.opener.postMessage(\r\n        {\r\n          type: 'error',\r\n          message: 'No Authorization Code Found.'\r\n        },\r\n        window.location.origin\r\n      )\r\n      window.close()\r\n      return\r\n    }\r\n\r\n    window.opener.postMessage(\r\n      {\r\n        type: ACCESS_TOKEN_GREASE_BOSS_EVENT,\r\n        authorization_code: code\r\n      },\r\n      window.location.origin\r\n    )\r\n    window.close()\r\n  }\r\n\r\n  listenToMessageEvent(resolve: any, reject: any): void {\r\n    const windowEventHandler = (event: MessageEvent): void => {\r\n      const hash = event.data\r\n      // eslint-disable-next-line no-console\r\n      if (hash.type === ACCESS_TOKEN_GREASE_BOSS_EVENT) {\r\n        const code = hash.authorization_code\r\n        resolve(code)\r\n      } else if (hash.type == 'error') {\r\n        console.error(hash.message)\r\n        reject(hash.message)\r\n      }\r\n      window.removeEventListener('message', windowEventHandler)\r\n    }\r\n    window.addEventListener('message', windowEventHandler, false)\r\n  }\r\n}\r\n"],"names":["AuthContext","React","createContext","undefined","useAuth","context","useContext","Error","withAuth","ComponentToWrap","WrappedComponent","props","authProps","displayName","name","AuthProvider","authService","children","Provider","value","base64URLEncode","str","toString","replace","sha256","buffer","createHash","update","digest","createPKCECodes","codeVerifier","randomBytes","codeChallenge","Buffer","from","createdAt","Date","codePair","toSnakeCase","split","join","toLowerCase","toUrlEncoded","obj","Object","keys","map","k","encodeURIComponent","UXType","POPUP_WIDTH","POPUP_HEIGHT","ACCESS_TOKEN_GREASE_BOSS_EVENT","AuthService","getUser","t","getAuthTokens","decoded","jwtDecode","id_token","getCodeFromLocation","location","length","pairs","pair","key","decodeURIComponent","removeCodeFromLocation","window","href","base","search","newSearch","param","filter","keyAndVal","history","replaceState","state","getItem","localStorage","removeItem","getPkce","pkce","JSON","parse","setAuthTokens","auth","refreshSlack","now","getTime","expires_at","expires_in","setItem","stringify","isPending","isAuthenticated","logout","shouldEndSession","token","logoutEndpoint","redirectUri","id_token_hint","access_token","query","post_logout_redirect_uri","url","reload","login","authorize","getAuthorizeUri","clientId","provider","authorizeEndpoint","scopes","audience","scope","responseType","codeChallengeMethod","authenticate","authenticateUsingOAuth","POPUP","response","fetchToken","then","restoreUri","e","console","warn","autoRefresh","startTimer","error","message","uxType","launchPopup","Promise","resolve","reject","listenToMessageEvent","code","isRefresh","clientSecret","contentType","tokenEndpoint","grantType","payload","refresh_token","fetch","headers","method","body","json","armRefreshTimer","refreshToken","timeoutDuration","timeout","clearTimeout","setTimeout","newRefreshToken","expiresAt","authTokens","left","screen","width","top","height","win","open","opener","timer","setInterval","a","document","createElement","URL","hostname","onLocationChangeHandler","clearInterval","log","postMessage","type","origin","close","authorization_code","windowEventHandler","event","hash","data","removeEventListener","addEventListener"],"mappings":"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"}